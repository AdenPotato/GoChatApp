<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chat - GoChatApp</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 10px;
        }
        .container {
            display: flex;
            gap: 20px;
            max-width: 1400px;
            margin: 0 auto;
        }
        .sidebar {
            width: 200px;
            flex-shrink: 0;
        }
        .main-chat {
            flex: 1;
            min-width: 0;
        }
        .users-sidebar {
            width: 150px;
            flex-shrink: 0;
        }
        .message {
            margin: 8px 0;
            padding: 8px;
            border-radius: 5px;
            background: #f5f5f5;
        }
        .message.own {
            background: #e3f2fd;
            text-align: right;
        }
        .message-content {
            word-wrap: break-word;
        }
        .message-reactions {
            margin-top: 5px;
            font-size: 0.9em;
        }
        .reaction {
            display: inline-block;
            margin: 2px;
            padding: 2px 6px;
            background: #fff;
            border: 1px solid #ddd;
            border-radius: 10px;
            cursor: pointer;
        }
        .reaction:hover {
            background: #f0f0f0;
        }
        .reaction.active {
            background: #ffd700;
        }
        .typing-indicator {
            font-style: italic;
            color: #666;
            font-size: 0.9em;
            margin: 5px 0;
            min-height: 20px;
        }
        .dm-list {
            max-height: 200px;
            overflow-y: auto;
            border: 1px solid #ccc;
            padding: 5px;
            margin-bottom: 10px;
        }
        .dm-item {
            padding: 5px;
            cursor: pointer;
            border-bottom: 1px solid #eee;
        }
        .dm-item:hover {
            background: #f0f0f0;
        }
        .dm-item.active {
            background: #e3f2fd;
            font-weight: bold;
        }
        .unread-badge {
            background: red;
            color: white;
            padding: 2px 6px;
            border-radius: 10px;
            font-size: 0.8em;
            margin-left: 5px;
        }
        .search-box {
            margin-bottom: 10px;
        }
        .blocked-users {
            margin-top: 10px;
            padding: 10px;
            border: 1px solid #ccc;
            border-radius: 5px;
        }
        .file-upload-area {
            margin: 10px 0;
            padding: 10px;
            border: 2px dashed #ccc;
            border-radius: 5px;
            text-align: center;
        }
        .message-image {
            max-width: 300px;
            border-radius: 5px;
            margin-top: 5px;
        }
        #messages {
            border: 1px solid #ccc;
            height: 400px;
            overflow-y: scroll;
            padding: 10px;
            margin-bottom: 10px;
        }
        button {
            cursor: pointer;
        }
        .room-btn, .dm-btn {
            width: 100%;
            margin-bottom: 5px;
            padding: 8px;
            text-align: left;
            border: 1px solid #ccc;
            background: white;
        }
        .room-btn.active, .dm-btn.active {
            font-weight: bold;
            background: #ddd;
        }
        .tab-buttons {
            display: flex;
            gap: 5px;
            margin-bottom: 10px;
        }
        .tab-btn {
            flex: 1;
            padding: 8px;
        }
        .tab-btn.active {
            background: #007bff;
            color: white;
        }
        .user-item {
            padding: 5px;
            border-bottom: 1px solid #eee;
        }
        .user-actions {
            font-size: 0.8em;
        }
        .user-actions button {
            margin-left: 5px;
            padding: 2px 5px;
            font-size: 0.8em;
        }
    </style>
</head>
<body>
    <h1>Chat - GoChatApp</h1>

    <div id="userInfo">
        <p>Logged in as: <strong id="currentUser"></strong></p>
        <button id="logoutBtn">Logout</button>
    </div>

    <hr>

    <div class="container">
        <!-- Left Sidebar - Rooms & DMs -->
        <div class="sidebar">
            <div class="tab-buttons">
                <button class="tab-btn active" id="roomsTab">Rooms</button>
                <button class="tab-btn" id="dmsTab">DMs</button>
            </div>

            <!-- Rooms Section -->
            <div id="roomsSection">
                <div id="roomsList"></div>
                <form id="createRoomForm">
                    <input type="text" id="newRoomName" placeholder="Room name" required style="width: 100%; margin-bottom: 5px;">
                    <button type="submit" style="width: 100%;">Create Room</button>
                </form>
            </div>

            <!-- DMs Section -->
            <div id="dmsSection" style="display: none;">
                <div class="dm-list" id="dmsList"></div>
                <form id="startDmForm">
                    <input type="number" id="newDmUserId" placeholder="User ID" required style="width: 100%; margin-bottom: 5px;">
                    <button type="submit" style="width: 100%;">Start DM</button>
                </form>
            </div>
        </div>

        <!-- Main Chat Area -->
        <div class="main-chat">
            <div class="search-box">
                <input type="text" id="searchInput" placeholder="Search messages..." style="width: 70%;">
                <button id="searchBtn">Search</button>
            </div>

            <h2>
                <span id="currentChatName">Global Chat</span>
                <span id="onlineIndicator" style="color: green; font-size: 0.8em;"></span>
            </h2>

            <div class="typing-indicator" id="typingIndicator"></div>

            <div id="messages">
                <p><em>Loading messages...</em></p>
            </div>

            <div class="file-upload-area" id="fileUploadArea" style="display: none;">
                <input type="file" id="fileInput" accept="image/*,video/*,.pdf,.doc,.docx">
                <p>Drag & drop files or click to upload</p>
            </div>

            <form id="messageForm">
                <input type="text" id="messageInput" placeholder="Type a message..." required style="width: 70%;">
                <button type="button" id="toggleUploadBtn">üìé</button>
                <button type="submit">Send</button>
            </form>
        </div>

        <!-- Right Sidebar - Users -->
        <div class="users-sidebar">
            <h3>Users</h3>
            <ul id="usersList" style="list-style: none; padding: 0;"></ul>

            <div class="blocked-users">
                <h4>Blocked</h4>
                <ul id="blockedList" style="list-style: none; padding: 0;"></ul>
            </div>
        </div>
    </div>

    <script>
        const token = localStorage.getItem('token');
        const user = JSON.parse(localStorage.getItem('user') || '{}');

        // Redirect to login if not authenticated
        if (!token || !user.id) {
            window.location.href = '/static/login.html';
        }

        // Display current user
        document.getElementById('currentUser').textContent = user.username || 'Unknown';

        // Logout functionality
        document.getElementById('logoutBtn').addEventListener('click', () => {
            if (ws) {
                ws.close();
            }
            localStorage.removeItem('token');
            localStorage.removeItem('user');
            window.location.href = '/static/login.html';
        });

        // Current chat state
        let currentRoomId = null;
        let currentConversationId = null;
        let currentChatType = 'global'; // 'global', 'room', or 'dm'
        let typingTimeout = null;
        let typingUsers = new Set();
        let messageReactions = {}; // Store reactions by message ID
        let blockedUserIds = new Set();

        // WebSocket connection
        let ws = null;
        let reconnectAttempts = 0;
        const maxReconnectAttempts = 5;
        let heartbeatInterval = null;

        function connectWebSocket() {
            const wsUrl = `ws://${window.location.host}/api/ws?token=${encodeURIComponent(token)}`;

            ws = new WebSocket(wsUrl);

            ws.onopen = () => {
                console.log('WebSocket connected');
                reconnectAttempts = 0;
                document.getElementById('onlineIndicator').textContent = '‚óè Online';
                addSystemMessage('Connected to chat');

                // Start heartbeat to keep connection alive
                startHeartbeat();
            };

            ws.onmessage = (event) => {
                try {
                    const data = JSON.parse(event.data);
                    handleWebSocketMessage(data);
                } catch (error) {
                    console.error('Error parsing WebSocket message:', error);
                }
            };

            ws.onerror = (error) => {
                console.error('WebSocket error:', error);
            };

            ws.onclose = () => {
                console.log('WebSocket disconnected');
                document.getElementById('onlineIndicator').textContent = '‚óè Offline';
                addSystemMessage('Disconnected from chat');
                stopHeartbeat();
                attemptReconnect();
            };
        }

        function startHeartbeat() {
            // Send a ping every 30 seconds to keep connection alive
            heartbeatInterval = setInterval(() => {
                if (ws && ws.readyState === WebSocket.OPEN) {
                    ws.send(JSON.stringify({ type: 'ping' }));
                }
            }, 30000);
        }

        function stopHeartbeat() {
            if (heartbeatInterval) {
                clearInterval(heartbeatInterval);
                heartbeatInterval = null;
            }
        }

        function attemptReconnect() {
            if (reconnectAttempts < maxReconnectAttempts) {
                reconnectAttempts++;
                console.log(`Attempting to reconnect... (${reconnectAttempts}/${maxReconnectAttempts})`);
                setTimeout(connectWebSocket, 2000 * reconnectAttempts);
            } else {
                addSystemMessage('Failed to reconnect. Please refresh the page.');
            }
        }

        function handleWebSocketMessage(data) {
            const messagesDiv = document.getElementById('messages');

            switch(data.type) {
                case 'message':
                case 'chat':
                    // Only show messages for current context
                    if (currentChatType === 'global' && !data.room_id && !data.conversation_id) {
                        addMessage(data);
                    } else if (currentChatType === 'room' && data.room_id === currentRoomId) {
                        addMessage(data);
                    } else if (currentChatType === 'dm' && data.conversation_id === currentConversationId) {
                        addMessage(data);
                    }
                    break;

                case 'user_joined':
                    if (currentChatType === 'global') {
                        addSystemMessage(`${data.username} joined the chat`);
                    }
                    loadUsers();
                    break;

                case 'user_left':
                    if (currentChatType === 'global') {
                        addSystemMessage(`${data.username} left the chat`);
                    }
                    loadUsers();
                    break;

                case 'room_user_joined':
                    if (data.room_id === currentRoomId) {
                        addSystemMessage(`${data.username} joined the room`);
                    }
                    break;

                case 'room_user_left':
                    if (data.room_id === currentRoomId) {
                        addSystemMessage(`${data.username} left the room`);
                    }
                    break;

                case 'typing':
                    if ((currentChatType === 'room' && data.room_id === currentRoomId) ||
                        (currentChatType === 'dm' && data.conversation_id === currentConversationId)) {
                        showTyping(data.username);
                    }
                    break;

                case 'stop_typing':
                    hideTyping(data.username);
                    break;

                case 'reaction':
                    updateReaction(data);
                    break;

                default:
                    console.log('Unknown message type:', data);
            }

            // Auto-scroll to bottom
            messagesDiv.scrollTop = messagesDiv.scrollHeight;
        }

        function addMessage(data) {
            const messagesDiv = document.getElementById('messages');
            const messageEl = document.createElement('div');
            const time = data.timestamp ? new Date(data.timestamp).toLocaleTimeString() : new Date().toLocaleTimeString();

            const isOwnMessage = data.user_id === user.id;
            messageEl.className = isOwnMessage ? 'message own' : 'message';
            messageEl.dataset.messageId = data.id || Date.now();

            let content = `<div class="message-content"><strong>${data.username}:</strong> ${escapeHtml(data.content)} <em style="font-size: 0.8em; color: #666;">(${time})</em></div>`;

            // Add reaction section
            content += `<div class="message-reactions" id="reactions-${messageEl.dataset.messageId}">`;
            content += `<button class="reaction-btn" onclick="addReaction(${messageEl.dataset.messageId}, 'üëç')">üëç</button>`;
            content += `<button class="reaction-btn" onclick="addReaction(${messageEl.dataset.messageId}, '‚ù§Ô∏è')">‚ù§Ô∏è</button>`;
            content += `<button class="reaction-btn" onclick="addReaction(${messageEl.dataset.messageId}, 'üòÇ')">üòÇ</button>`;
            content += `<span id="reaction-display-${messageEl.dataset.messageId}"></span>`;
            content += `</div>`;

            messageEl.innerHTML = content;
            messagesDiv.appendChild(messageEl);

            // Load reactions for this message if it has an ID
            if (data.id) {
                loadReactionsForMessage(data.id);
            }
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function addSystemMessage(message) {
            const messagesDiv = document.getElementById('messages');
            const messageEl = document.createElement('div');
            messageEl.style.textAlign = 'center';
            messageEl.style.color = '#666';
            messageEl.style.fontStyle = 'italic';
            messageEl.style.margin = '10px 0';
            messageEl.textContent = message;
            messagesDiv.appendChild(messageEl);
        }

        function showTyping(username) {
            if (username !== user.username) {
                typingUsers.add(username);
                updateTypingIndicator();
            }
        }

        function hideTyping(username) {
            typingUsers.delete(username);
            updateTypingIndicator();
        }

        function updateTypingIndicator() {
            const indicator = document.getElementById('typingIndicator');
            if (typingUsers.size === 0) {
                indicator.textContent = '';
            } else if (typingUsers.size === 1) {
                indicator.textContent = `${Array.from(typingUsers)[0]} is typing...`;
            } else {
                indicator.textContent = `${typingUsers.size} people are typing...`;
            }
        }

        // Load messages based on context
        async function loadMessages() {
            try {
                let url = '/api/messages';

                if (currentChatType === 'room' && currentRoomId) {
                    url = `/api/messages?room_id=${currentRoomId}`;
                } else if (currentChatType === 'dm' && currentConversationId) {
                    url = `/api/conversations/${currentConversationId}/messages`;
                }

                const response = await fetch(url, {
                    headers: {
                        'Authorization': 'Bearer ' + token
                    }
                });

                const data = await response.json();
                const messagesDiv = document.getElementById('messages');
                messagesDiv.innerHTML = '';

                if (response.ok && data.messages && data.messages.length > 0) {
                    data.messages.reverse().forEach(msg => {
                        addMessage({
                            id: msg.id,
                            user_id: msg.user_id || msg.sender_id,
                            username: msg.user?.username || msg.sender?.username || 'Unknown',
                            content: msg.content,
                            timestamp: msg.created_at
                        });
                    });
                } else {
                    addSystemMessage('No previous messages');
                }

                messagesDiv.scrollTop = messagesDiv.scrollHeight;
            } catch (error) {
                console.error('Error loading messages:', error);
                addSystemMessage('Error loading messages');
            }
        }

        // Load users
        async function loadUsers() {
            try {
                const response = await fetch('/api/users');
                const data = await response.json();
                const usersList = document.getElementById('usersList');

                if (response.ok && data.users && data.users.length > 0) {
                    usersList.innerHTML = '';
                    data.users.forEach(u => {
                        if (blockedUserIds.has(u.id)) return;

                        const li = document.createElement('li');
                        li.className = 'user-item';

                        let html = `<div>${u.username}`;
                        if (u.id === user.id) {
                            html += ' (you)';
                        }
                        html += '</div>';

                        if (u.id !== user.id) {
                            html += `<div class="user-actions">
                                <button onclick="startDM(${u.id})">DM</button>
                                <button onclick="blockUser(${u.id})">Block</button>
                            </div>`;
                        }

                        li.innerHTML = html;
                        usersList.appendChild(li);
                    });
                } else {
                    usersList.innerHTML = '<li><em>No users</em></li>';
                }
            } catch (error) {
                console.error('Error loading users:', error);
            }
        }

        // Load blocked users
        async function loadBlockedUsers() {
            try {
                const response = await fetch('/api/blocks', {
                    headers: {
                        'Authorization': 'Bearer ' + token
                    }
                });
                const data = await response.json();
                const blockedList = document.getElementById('blockedList');

                blockedUserIds.clear();

                if (response.ok && data.blocked_users && data.blocked_users.length > 0) {
                    blockedList.innerHTML = '';
                    data.blocked_users.forEach(block => {
                        blockedUserIds.add(block.blocked_id);
                        const li = document.createElement('li');
                        li.innerHTML = `
                            ${block.blocked.username}
                            <button onclick="unblockUser(${block.blocked_id})" style="font-size: 0.8em;">Unblock</button>
                        `;
                        blockedList.appendChild(li);
                    });
                } else {
                    blockedList.innerHTML = '<li><em>None</em></li>';
                }

                loadUsers(); // Refresh users list
            } catch (error) {
                console.error('Error loading blocked users:', error);
            }
        }

        // Block/Unblock users
        async function blockUser(userId) {
            try {
                const response = await fetch(`/api/users/${userId}/block`, {
                    method: 'POST',
                    headers: {
                        'Authorization': 'Bearer ' + token
                    }
                });

                if (response.ok) {
                    loadBlockedUsers();
                } else {
                    const data = await response.json();
                    alert('Error: ' + (data.error || 'Failed to block user'));
                }
            } catch (error) {
                alert('Error: ' + error.message);
            }
        }

        async function unblockUser(userId) {
            try {
                const response = await fetch(`/api/users/${userId}/block`, {
                    method: 'DELETE',
                    headers: {
                        'Authorization': 'Bearer ' + token
                    }
                });

                if (response.ok) {
                    loadBlockedUsers();
                } else {
                    const data = await response.json();
                    alert('Error: ' + (data.error || 'Failed to unblock user'));
                }
            } catch (error) {
                alert('Error: ' + error.message);
            }
        }

        // Send message via WebSocket
        document.getElementById('messageForm').addEventListener('submit', (e) => {
            e.preventDefault();

            const content = document.getElementById('messageInput').value.trim();

            if (!content) {
                return;
            }

            if (currentChatType === 'dm') {
                // Send DM via HTTP API
                sendDM(content);
            } else if (ws && ws.readyState === WebSocket.OPEN) {
                const message = {
                    type: 'chat',
                    content: content
                };
                if (currentRoomId) {
                    message.room_id = currentRoomId;
                }
                ws.send(JSON.stringify(message));
                document.getElementById('messageInput').value = '';

                // Stop typing indicator
                ws.send(JSON.stringify({ type: 'stop_typing', room_id: currentRoomId }));
            } else {
                addSystemMessage('Cannot send message: Not connected');
            }
        });

        // Typing indicator
        document.getElementById('messageInput').addEventListener('input', (e) => {
            if (!ws || ws.readyState !== WebSocket.OPEN) return;

            // Clear existing timeout
            if (typingTimeout) {
                clearTimeout(typingTimeout);
            }

            // Send typing indicator
            const message = { type: 'typing' };
            if (currentRoomId) {
                message.room_id = currentRoomId;
            }
            if (currentConversationId) {
                message.conversation_id = currentConversationId;
            }
            ws.send(JSON.stringify(message));

            // Stop typing after 2 seconds of inactivity
            typingTimeout = setTimeout(() => {
                const stopMessage = { type: 'stop_typing' };
                if (currentRoomId) {
                    stopMessage.room_id = currentRoomId;
                }
                if (currentConversationId) {
                    stopMessage.conversation_id = currentConversationId;
                }
                ws.send(JSON.stringify(stopMessage));
            }, 2000);
        });

        // Load rooms
        async function loadRooms() {
            try {
                const response = await fetch('/api/rooms');
                const data = await response.json();
                const roomsList = document.getElementById('roomsList');

                roomsList.innerHTML = '';

                // Add global chat option
                const globalBtn = document.createElement('button');
                globalBtn.className = 'room-btn';
                globalBtn.textContent = 'Global Chat';
                globalBtn.onclick = () => switchToGlobal();
                if (currentChatType === 'global') {
                    globalBtn.classList.add('active');
                }
                roomsList.appendChild(globalBtn);

                if (response.ok && data.rooms && data.rooms.length > 0) {
                    data.rooms.forEach(room => {
                        const roomBtn = document.createElement('button');
                        roomBtn.className = 'room-btn';
                        roomBtn.textContent = room.name;
                        roomBtn.onclick = () => switchToRoom(room.id, room.name);
                        if (currentChatType === 'room' && currentRoomId === room.id) {
                            roomBtn.classList.add('active');
                        }
                        roomsList.appendChild(roomBtn);
                    });
                }
            } catch (error) {
                console.error('Error loading rooms:', error);
            }
        }

        // Load DM conversations
        async function loadConversations() {
            try {
                const response = await fetch('/api/conversations', {
                    headers: {
                        'Authorization': 'Bearer ' + token
                    }
                });
                const data = await response.json();
                const dmsList = document.getElementById('dmsList');

                dmsList.innerHTML = '';

                if (response.ok && data.conversations && data.conversations.length > 0) {
                    data.conversations.forEach(conv => {
                        const otherUser = conv.user1_id === user.id ? conv.user2 : conv.user1;
                        const dmItem = document.createElement('div');
                        dmItem.className = 'dm-item';
                        dmItem.textContent = otherUser.username;
                        dmItem.onclick = () => switchToDM(conv.id, otherUser.username);
                        if (currentChatType === 'dm' && currentConversationId === conv.id) {
                            dmItem.classList.add('active');
                        }
                        dmsList.appendChild(dmItem);
                    });
                } else {
                    dmsList.innerHTML = '<p><em>No conversations</em></p>';
                }
            } catch (error) {
                console.error('Error loading conversations:', error);
            }
        }

        // Switch chat contexts
        function switchToGlobal() {
            // Leave current room if in one
            if (currentRoomId && ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({ type: 'leave_room', room_id: currentRoomId }));
            }

            currentChatType = 'global';
            currentRoomId = null;
            currentConversationId = null;
            document.getElementById('currentChatName').textContent = 'Global Chat';
            typingUsers.clear();
            updateTypingIndicator();
            loadMessages();
            loadRooms();
        }

        function switchToRoom(roomId, roomName) {
            // Leave current room if in one
            if (currentRoomId && ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({ type: 'leave_room', room_id: currentRoomId }));
            }

            currentChatType = 'room';
            currentRoomId = roomId;
            currentConversationId = null;
            document.getElementById('currentChatName').textContent = roomName;
            typingUsers.clear();
            updateTypingIndicator();

            // Join new room
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({ type: 'join_room', room_id: roomId }));
            }

            loadMessages();
            loadRooms();
        }

        function switchToDM(conversationId, username) {
            // Leave current room if in one
            if (currentRoomId && ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({ type: 'leave_room', room_id: currentRoomId }));
            }

            currentChatType = 'dm';
            currentRoomId = null;
            currentConversationId = conversationId;
            document.getElementById('currentChatName').textContent = `DM with ${username}`;
            typingUsers.clear();
            updateTypingIndicator();
            loadMessages();
            loadConversations();
        }

        // Create room
        document.getElementById('createRoomForm').addEventListener('submit', async (e) => {
            e.preventDefault();
            const roomName = document.getElementById('newRoomName').value.trim();
            if (!roomName) return;

            try {
                const response = await fetch('/api/rooms', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': 'Bearer ' + token
                    },
                    body: JSON.stringify({ name: roomName })
                });

                const data = await response.json();
                if (response.ok) {
                    document.getElementById('newRoomName').value = '';
                    loadRooms();
                    switchToRoom(data.room.id, data.room.name);
                } else {
                    alert('Error: ' + (data.error || 'Failed to create room'));
                }
            } catch (error) {
                alert('Error: ' + error.message);
            }
        });

        // Start DM
        async function startDM(userId) {
            try {
                const response = await fetch('/api/conversations', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': 'Bearer ' + token
                    },
                    body: JSON.stringify({ user_id: userId })
                });

                const data = await response.json();
                if (response.ok) {
                    // Switch to DMs tab
                    document.getElementById('dmsTab').click();
                    loadConversations();

                    // Switch to the conversation
                    const otherUser = data.conversation.user1_id === user.id ?
                        data.conversation.user2 : data.conversation.user1;
                    switchToDM(data.conversation.id, otherUser.username);
                } else {
                    alert('Error: ' + (data.error || 'Failed to start conversation'));
                }
            } catch (error) {
                alert('Error: ' + error.message);
            }
        }

        document.getElementById('startDmForm').addEventListener('submit', async (e) => {
            e.preventDefault();
            const userId = parseInt(document.getElementById('newDmUserId').value);
            if (!userId) return;

            await startDM(userId);
            document.getElementById('newDmUserId').value = '';
        });

        // Send DM
        async function sendDM(content) {
            if (!currentConversationId) return;

            try {
                const response = await fetch(`/api/conversations/${currentConversationId}/messages`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': 'Bearer ' + token
                    },
                    body: JSON.stringify({ content: content })
                });

                const data = await response.json();
                if (response.ok) {
                    document.getElementById('messageInput').value = '';
                    loadMessages(); // Reload to show new message
                } else {
                    alert('Error: ' + (data.error || 'Failed to send message'));
                }
            } catch (error) {
                alert('Error: ' + error.message);
            }
        }

        // Reactions
        async function addReaction(messageId, emoji) {
            try {
                const response = await fetch(`/api/messages/${messageId}/reactions`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': 'Bearer ' + token
                    },
                    body: JSON.stringify({ emoji: emoji })
                });

                const data = await response.json();
                if (response.ok) {
                    loadReactionsForMessage(messageId);
                } else {
                    console.error('Error adding reaction:', data.error);
                }
            } catch (error) {
                console.error('Error adding reaction:', error);
            }
        }

        async function loadReactionsForMessage(messageId) {
            try {
                const response = await fetch(`/api/messages/${messageId}/reactions`);
                const data = await response.json();

                if (response.ok && data.counts) {
                    const display = document.getElementById(`reaction-display-${messageId}`);
                    if (display) {
                        let html = ' ';
                        for (const [emoji, count] of Object.entries(data.counts)) {
                            html += `<span class="reaction">${emoji} ${count}</span> `;
                        }
                        display.innerHTML = html;
                    }
                }
            } catch (error) {
                console.error('Error loading reactions:', error);
            }
        }

        function updateReaction(data) {
            // Refresh reactions for the message
            if (data.message_id) {
                loadReactionsForMessage(data.message_id);
            }
        }

        // Message search
        document.getElementById('searchBtn').addEventListener('click', async () => {
            const query = document.getElementById('searchInput').value.trim();
            if (!query) return;

            try {
                let url = `/api/messages/search?q=${encodeURIComponent(query)}`;
                if (currentRoomId) {
                    url += `&room_id=${currentRoomId}`;
                }

                const response = await fetch(url);
                const data = await response.json();
                const messagesDiv = document.getElementById('messages');

                messagesDiv.innerHTML = '';
                addSystemMessage(`Search results for: "${query}"`);

                if (response.ok && data.messages && data.messages.length > 0) {
                    data.messages.forEach(msg => {
                        addMessage({
                            id: msg.id,
                            user_id: msg.user_id,
                            username: msg.user?.username || 'Unknown',
                            content: msg.content,
                            timestamp: msg.created_at
                        });
                    });
                    addSystemMessage(`Found ${data.count} results`);
                } else {
                    addSystemMessage('No results found');
                }
            } catch (error) {
                console.error('Error searching messages:', error);
                addSystemMessage('Error searching messages');
            }
        });

        // File upload toggle
        document.getElementById('toggleUploadBtn').addEventListener('click', () => {
            const uploadArea = document.getElementById('fileUploadArea');
            uploadArea.style.display = uploadArea.style.display === 'none' ? 'block' : 'none';
        });

        // File upload
        document.getElementById('fileInput').addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (!file) return;

            const formData = new FormData();
            formData.append('file', file);

            try {
                const response = await fetch('/api/upload', {
                    method: 'POST',
                    headers: {
                        'Authorization': 'Bearer ' + token
                    },
                    body: formData
                });

                const data = await response.json();
                if (response.ok) {
                    // Send the file URL as a message
                    const fileUrl = data.url || data.file_path;
                    document.getElementById('messageInput').value = `[File] ${fileUrl}`;
                    document.getElementById('fileUploadArea').style.display = 'none';
                    document.getElementById('fileInput').value = '';
                } else {
                    alert('Error: ' + (data.error || 'Failed to upload file'));
                }
            } catch (error) {
                alert('Error: ' + error.message);
            }
        });

        // Tab switching
        document.getElementById('roomsTab').addEventListener('click', () => {
            document.getElementById('roomsTab').classList.add('active');
            document.getElementById('dmsTab').classList.remove('active');
            document.getElementById('roomsSection').style.display = 'block';
            document.getElementById('dmsSection').style.display = 'none';
        });

        document.getElementById('dmsTab').addEventListener('click', () => {
            document.getElementById('dmsTab').classList.add('active');
            document.getElementById('roomsTab').classList.remove('active');
            document.getElementById('dmsSection').style.display = 'block';
            document.getElementById('roomsSection').style.display = 'none';
            loadConversations();
        });

        // Initialize
        loadMessages();
        loadUsers();
        loadRooms();
        loadBlockedUsers();
        connectWebSocket();
    </script>
</body>
</html>
